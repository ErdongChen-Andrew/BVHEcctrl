/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: sirsaugsage (https://sketchfab.com/sirsausage)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/fantasy-game-inn-192bf30a7e28425ab385aef19769d4b0
Title: Fantasy Game Inn
*/

import * as THREE from "three";
import { Clone, Helper, Merged, useGLTF, useHelper } from "@react-three/drei";
import { useEffect, useMemo, useRef } from "react";
import { MeshBVHHelper } from "three-mesh-bvh";
import { useEcctrlStore } from "../src/stores/useEcctrlStore";
import { useThree } from "@react-three/fiber";

export default function InstancedMap(props) {
  // Load map model
  const { scene } = useThree();
  const bakeInnModel = useGLTF("./fantasy_game_inn.glb");
  const instancedMeshRef = useRef();
  const temp = new THREE.Object3D();

  const count = 100;
  const scale = 2; //0.09;
  const spacingX = 10;
  const spacingZ = 14.5;
  function generateSpiralPositions(count, spacingX, spacingZ) {
    const positions = [];
    let x = 0;
    let z = 0;
    let dx = 1;
    let dz = 0;
    let steps = 1;
    let stepCount = 0;
    let directionChanges = 0;

    positions.push([0, 0, 0]); // First at center

    for (let i = 1; i < count; i++) {
      x += dx;
      z += dz;
      positions.push([x * spacingX, 0, z * spacingZ]);

      stepCount++;
      if (stepCount >= steps) {
        stepCount = 0;
        // Change direction clockwise (right → down → left → up)
        [dx, dz] = [-dz, dx];
        directionChanges++;

        // Every two direction changes, increase step size
        if (directionChanges % 2 === 0) {
          steps++;
        }
      }
    }

    return positions;
  }

  // useHelper(instancedMeshRef, MeshBVHHelper, 20)

  const geo = useMemo(() => new THREE.BoxGeometry(1, 1, 1), []);
  const sphereGeo = useMemo(() => new THREE.SphereGeometry(1), []);
  const mat = useMemo(() => new THREE.MeshStandardMaterial(), []);
  useEffect(() => {
    const spiralPositions = generateSpiralPositions(count, spacingX, spacingZ);

    for (let i = 0; i < count; i++) {
      const pos = spiralPositions[i];
      if (!pos) break;

      temp.position.set(pos[0], -2, pos[2]);
      temp.rotation.set(-Math.PI / 2, 0, 0); //-Math.PI / 2
      temp.scale.set(
        scale *2 , //* (Math.random()+0.5),
        scale , //* (Math.random()+0.5),
        scale , //* (Math.random()+0.5)
      );
      // temp.scale.set(scale, scale, scale);
      temp.updateMatrix();

      instancedMeshRef.current.setMatrixAt(i, temp.matrix);
    }

    instancedMeshRef.current.instanceMatrix.needsUpdate = true;
  }, []);

  return (
    <group {...props} dispose={null}>
      {/* <Clone object={bakeInnModel.scene} position={[-33, -8, -2]} /> */}
      {/* <mesh
        castShadow
        receiveShadow
        geometry={bakeInnModel.nodes.TheInn_bakeInn_0.geometry}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.11}
      >
        <meshStandardMaterial map={bakeInnModel.materials.bakeInn.map} />
      </mesh> */}

      {/* <instancedMesh
        ref={instancedMeshRef}
        args={[
          bakeInnModel.nodes.TheInn_bakeInn_0.geometry,
          bakeInnModel.materials.bakeInn,
          count,
        ]}
      /> */}

      <instancedMesh
        ref={instancedMeshRef}
        args={[geo, mat, count]}
        position={[2, -1, 0]}
        scale={0.5}
      />
    </group>
  );
}

useGLTF.preload("./fantasy_game_inn.glb");
